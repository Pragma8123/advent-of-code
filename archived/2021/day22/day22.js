// generated by prepare script
const MATCHER =
  /(on|off) x=(-?\d+)\.\.(-?\d+),y=(-?\d+)\.\.(-?\d+),z=(-?\d+)\.\.(-?\d+)/;

export const transformInput = (o) => {
  return o.split(/\n/).map((l) => {
    const [, str, x1, x2, y1, y2, z1, z2] = l.match(MATCHER);

    return [
      str === 'on',
      parseInt(x1, 10),
      parseInt(y1, 10),
      parseInt(z1, 10),
      parseInt(x2, 10) + 1,
      parseInt(y2, 10) + 1,
      parseInt(z2, 10) + 1
    ];
  });
};

export class Cuboid {
  constructor (x1, y1, z1, x2, y2, z2) {
    this.p1 = { x: x1, y: y1, z: z1 };
    this.p2 = { x: x2, y: y2, z: z2 };
  }

  get height () {
    return Math.abs(this.p1.y - this.p2.y);
  }

  get width () {
    return Math.abs(this.p1.x - this.p2.x);
  }

  get depth () {
    return Math.abs(this.p1.z - this.p2.z);
  }

  get volume () {
    return this.height * this.width * this.depth;
  }

  get center () {
    return {
      x: this.p1.x + this.width / 2,
      y: this.p1.y + this.height / 2,
      z: this.p1.z + this.depth / 2
    };
  }

  getContained (...points) {
    return points.filter((p) => {
      if (p.x < this.p1.x) return false;
      if (p.x >= this.p2.x) return false;
      if (p.y < this.p1.y) return false;
      if (p.y >= this.p2.y) return false;
      if (p.z < this.p1.z) return false;
      if (p.z >= this.p2.z) return false;

      return true;
    });
  }
}

export const getRemainingCuboids = (c1, c2) => {
  const noInteraction =
    c2.p2.x <= c1.p1.x ||
    c2.p1.x >= c1.p2.x ||
    c2.p2.y <= c1.p1.y ||
    c2.p1.y >= c1.p2.y ||
    c2.p2.z <= c1.p1.z ||
    c2.p1.z >= c1.p2.z;

  if (noInteraction) return [c1];

  const cubes = [];

  if (c2.p1.y > c1.p1.y) {
    cubes.push(
      new Cuboid(c1.p1.x, c1.p1.y, c1.p1.z, c1.p2.x, c2.p1.y, c1.p2.z)
    );
  }

  if (c2.p2.y < c1.p2.y) {
    cubes.push(
      new Cuboid(c1.p1.x, c2.p2.y, c1.p1.z, c1.p2.x, c1.p2.y, c1.p2.z)
    );
  }

  const minY = c2.p1.y >= c1.p1.y ? c2.p1.y : c1.p1.y;
  const maxY = c2.p2.y <= c1.p2.y ? c2.p2.y : c1.p2.y;

  if (c2.p1.z > c1.p1.z) {
    cubes.push(new Cuboid(c1.p1.x, minY, c1.p1.z, c1.p2.x, maxY, c2.p1.z));
  }

  if (c2.p2.z < c1.p2.z) {
    cubes.push(new Cuboid(c1.p1.x, minY, c2.p2.z, c1.p2.x, maxY, c1.p2.z));
  }

  const minZ = c2.p1.z >= c1.p1.z ? c2.p1.z : c1.p1.z;
  const maxZ = c2.p2.z <= c1.p2.z ? c2.p2.z : c1.p2.z;

  if (c2.p1.x > c1.p1.x) {
    cubes.push(new Cuboid(c1.p1.x, minY, minZ, c2.p1.x, maxY, maxZ));
  }

  if (c2.p2.x < c1.p2.x) {
    cubes.push(new Cuboid(c2.p2.x, minY, minZ, c1.p2.x, maxY, maxZ));
  }

  return cubes;
};

export const getCuboidsForInput = (input) => {
  const cubes = [];

  for (const entry of input) {
    const [on, ...cords] = entry;

    const c2 = new Cuboid(...cords);

    for (let i = cubes.length - 1; i >= 0; i -= 1) {
      const c1 = cubes[i];
      cubes.splice(i, 1, ...getRemainingCuboids(c1, c2));
    }

    if (on) cubes.push(c2);
  }

  return cubes;
};

export const solve = (input) => {
  const cuboids = getCuboidsForInput(input);
  return cuboids.reduce((t, c) => t + c.volume, 0);
};
