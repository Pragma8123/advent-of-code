// generated by prepare script
import { getDistinctPairs } from '../../helpers/getDistinctPairs.js';

class SnailNumber {
  constructor(arr, parent) {
    let [a, b] = arr;

    if (a instanceof SnailNumber) a.parent = this;
    if (Array.isArray(a)) a = new SnailNumber(a, this);

    if (b instanceof SnailNumber) b.parent = this;
    if (Array.isArray(b)) b = new SnailNumber(b, this);

    this.elements = [a, b];
    this.parent = parent;
  }

  isRegularPair() {
    return this.elements.every((el) => !(el instanceof SnailNumber));
  }

  toJSON() {
    return this.elements;
  }

  magnitude() {
    const [a, b] = this.elements.map((el) =>
      el instanceof SnailNumber ? el.magnitude() : el
    );

    return 3 * a + 2 * b;
  }
}

const findNestedPair = (snailNumber, depth = 1) => {
  if (depth === 5 && snailNumber.isRegularPair()) {
    return snailNumber;
  }

  for (const childEl of snailNumber.elements) {
    if (childEl instanceof SnailNumber) {
      const pair = findNestedPair(childEl, depth + 1);
      if (pair) return pair;
    }
  }

  return null;
};

const findElementToSplit = (snailNumber) => {
  for (let i = 0; i < 2; i += 1) {
    const childEl = snailNumber.elements[i];

    if (childEl instanceof SnailNumber) {
      const found = findElementToSplit(childEl);
      if (found) return found;
    }

    if (childEl >= 10) return [snailNumber, i];
  }

  return null;
};

const explode = (explodeTarget) => {
  const [a, b] = explodeTarget.elements;
  let current;

  current = explodeTarget;
  while (current.parent) {
    if (current.parent.elements.indexOf(current) === 1) {
      if (current.parent.elements[0] instanceof SnailNumber) {
        let target = current.parent.elements[0];

        while (target.elements[1] instanceof SnailNumber) {
          target = target.elements[1];
        }

        target.elements[1] += a;
      } else {
        current.parent.elements[0] += a;
      }
      break;
    }

    current = current.parent;
  }

  current = explodeTarget;
  while (current.parent) {
    if (current.parent.elements.indexOf(current) === 0) {
      if (current.parent.elements[1] instanceof SnailNumber) {
        let target = current.parent.elements[1];

        while (target.elements[0] instanceof SnailNumber) {
          target = target.elements[0];
        }

        target.elements[0] += b;
      } else {
        current.parent.elements[1] += b;
      }
      break;
    }

    current = current.parent;
  }

  explodeTarget.parent.elements[
    explodeTarget.parent.elements.indexOf(explodeTarget)
  ] = 0;
};

const split = (val) => {
  let half = val / 2;
  let a = Math.floor(half);
  let b = Math.ceil(half);

  return [a, b];
};

const reduce = (num) => {
  const nextReduce = (currentEl) => {
    const nestedPair = findNestedPair(num);

    if (nestedPair) {
      explode(nestedPair);
      return true;
    }

    const elementToSplit = findElementToSplit(currentEl);
    if (elementToSplit) {
      const [parent, index] = elementToSplit;
      const value = parent.elements[index];

      const newSnailNumber = new SnailNumber(split(value), parent);
      parent.elements[index] = newSnailNumber;
  
      return true;
    }

    return false;
  };

  let shouldContinue = true;
  while (shouldContinue) {
    shouldContinue = nextReduce(num);
  }

  return num;
};

export const addNums = (...nums) => {
  let output = new SnailNumber(nums.shift());

  while (nums.length) {
    let addend = new SnailNumber(nums.shift());
    output = new SnailNumber([output, addend]);
    reduce(output);
  }

  return output;
};

const addParents = (arr) => {
  for (const el of arr) {
    if (Array.isArray(el)) {
      if (!el.parent) el.parent = arr;
      addParents(el);
    }
  }

  return arr;
};

export const part1 = (input) => {
  let num = addNums(...input);

  return num.magnitude();
};

export const part2 = (input) => {
  const pairs = getDistinctPairs(input);
  let max = 0;

  for (const pair of pairs) {
    let [a, b] = pair;
    let mag = Math.max(addNums(a, b).magnitude(), addNums(b, a).magnitude());
    if (mag > max) max = mag;
  }

  return max;
};
