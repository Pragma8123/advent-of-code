// generated by prepare script
const getCounts = (poly) => {
  const counts = {};

  for (const char of poly) {
    if (counts[char]) {
      counts[char] += 1;
    } else {
      counts[char] = 1;
    }
  }

  return Object.values(counts).sort((a, b) => b - a);
};

export const part1 = (input, steps = 10) => {
  const [, rules] = input;
  let [poly] = input;
  for (let i = 0; i < steps; i += 1) {
    let newPoly = "";
    for (const curr of poly) {
      const last = newPoly[newPoly.length - 1];
      if (last) {
        const insertChar = rules[`${last}${curr}`];
        if (insertChar) newPoly += insertChar;
      }
      newPoly += curr;
    }
    poly = newPoly;
  }
  const counts = getCounts(poly);
  return counts[0] - counts[counts.length - 1];
};

const createBits = (poly) => {
  const bits = {};
  for (let i = 0; i < poly.length - 1; i += 1) {
    const bit = poly.slice(i, i + 2);
    if (bits[bit] === undefined) bits[bit] = 0;
    bits[bit] += 1;
  }
  return bits;
};

const enhanceRules = (rules) => {
  Object.entries(rules).forEach(([key, add]) => {
    rules[key] = [`${key[0]}${add}`, `${add}${key[1]}`];
  });
};

export const part2 = (input, steps = 10) => {
  const counts = {};
  const addCharCount = (char, count) => {
    if (counts[char] === undefined) {
      counts[char] = count;
    } else {
      counts[char] += count;
    }
  };

  let [poly, rules] = input;
  enhanceRules(rules);
  let bits = createBits(poly);

  for (let i = 0; i < steps; i += 1) {
    const newBits = { ...bits };

    for (let bit in rules) {
      if (bits[bit]) {
        newBits[bit] -= bits[bit];
        rules[bit].forEach((newBit) => {
          if (newBits[newBit] === undefined) newBits[newBit] = 0;
          newBits[newBit] += bits[bit];
        });
      }
    }

    bits = newBits;
  }

  addCharCount(poly[0], 1);
  for (const bit in bits) {
    const char = bit[1];
    const value = bits[bit];
    if (value) addCharCount(char, value);
  }

  const countValues = Object.values(counts);
  const max = Math.max(...countValues);
  const min = Math.min(...countValues);

  return max - min;
};
