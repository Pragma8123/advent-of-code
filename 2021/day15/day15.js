// generated by prepare script
import { manhattan } from "../../helpers/manhattan.js";
import { readInput } from "../../helpers/readInput.js";

class Position {
  constructor(x, y, value, map) {
    this.x = x;
    this.y = y;
    this.value = value;
    this.map = map;
  }

  get neighbors() {
    return [
      this.map.getPosition(this.x - 1, this.y),
      this.map.getPosition(this.x + 1, this.y),
      this.map.getPosition(this.x, this.y + 1),
      this.map.getPosition(this.x, this.y - 1),
    ].filter(Boolean);
  }
}

class ChitonMap {
  constructor(input) {
    this.data = input.map((row, y) =>
      row.map((value, x) => new Position(x, y, value, this))
    );

    this.maxX = input[0].length - 1;
    this.maxY = input.length - 1;
  }

  getPosition(x, y) {
    return this.data[y]?.[x] ?? null;
  }

  forEach(cb) {
    this.data.forEach((row) => row.forEach((pos) => cb(pos)));
  }
}

const aStar = (map) => {
  const open = [map.getPosition(0, 0)];

  map.forEach((pos) => {
    const isStart = !!(pos.x + pos.y);

    pos.d = isStart ? Infinity : 0;
    pos.h = isStart ? manhattan(pos, { x: map.maxX, y: map.maxY }) : 0;
    pos.f = pos.d + pos.h;
  });

  while (true) {
    const next = open.sort((a, b) => b.f - a.f).pop();

    const isEnd = next.x === map.maxX && next.y === map.maxY;
    if (isEnd) return next.d;

    const unvisitedNeighbors = next.neighbors.filter((n) => !n.visited);
    unvisitedNeighbors.forEach((un) => {
      const d = next.d + un.value;
      if (d < un.d) {
        un.d = d;
        un.f = d + un.h;
      }

      if (!open.includes(un)) open.push(un);
    });

    next.visited = true;
  }
};

export const part1 = (input) => {
  const map = new ChitonMap(input);

  return aStar(map);
};

const addToValue = (a, b) => ((a + b - 1) % 9) + 1;

export const enlargeInput = (input) => {
  let wider = input.map((row) => {
    const widerRow = [...row];
    for (let i = 1; i < 5; i += 1) {
      widerRow.push(...row.map((n) => addToValue(n, i)));
    }
    return widerRow;
  });

  let output = [...wider];
  for (let i = 1; i < 5; i += 1) {
    output.push(...wider.map((row) => row.map((n) => addToValue(n, i))));
  }

  return output;
};

export const part2 = (input) => {
  const map = new ChitonMap(enlargeInput(input));

  return aStar(map);
};

const parseOpts = {
  transform: (o) => o.split(/\n/).map((l, y) => l.split("").map(Number)),
};
