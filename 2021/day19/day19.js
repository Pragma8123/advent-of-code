// generated by prepare script

import { getDistinctPairs } from "../../helpers/getDistinctPairs.js";
import { manhattan } from "../../helpers/manhattan.js";
class Point {
  constructor({ x, y, z }) {
    this.x = x;
    this.y = y;
    this.z = z;
    // this.region = null;
  }

  toJSON() {
    const { x, y, z } = this;
    return { x, y, z };
  }

  toString() {
    const { x, y, z } = this;
    return `(${x}, ${y}, ${z})`;
  }

  translate({ x, y, z }) {
    this.x += x;
    this.y += y;
    this.z += z;
  }

  reflect() {
    let [x, y, z] = ["x", "y", "z"].map((a) =>
      a == "y" ? this[a] : this[a] * -1
    );
    Object.assign(this, { x, y, z });
  }

  roll() {
    let [x, y, z] = [this.x, this.z, -1 * this.y];
    Object.assign(this, { x, y, z });
  }

  turn() {
    let [x, y, z] = [-1 * this.y, this.x, this.z];
    Object.assign(this, { x, y, z });
  }

  turnReverse() {
    let [x, y, z] = [this.y, -1 * this.x, this.z];
    Object.assign(this, { x, y, z });
  }
}

class Scanner extends Point {
  constructor(id) {
    super({ x: 0, y: 0, z: 0 });
    this.id = id;
  }
}

class Beacon extends Point {
  constructor(xyz) {
    super(xyz);
  }
}

const checkIfSamePos = (a, b) => {
  return b.x === a.x && b.y === a.y && b.z === a.z;
};

class Region {
  constructor(id) {
    this.id = id;
    this.scanners = [];
    this.beacons = [];
  }

  addScanner(...scanners) {
    for (const scanner of scanners) {
      this.scanners.push(scanner);
    }
  }

  addBeacon(...beacons) {
    for (const beacon of beacons) {
      this.beacons.push(beacon);
    }
  }

  getNeighborDistances() {
    const neighborDistances = new Map(this.beacons.map((b) => [b, new Map()]));

    for (const [b1, d1] of neighborDistances) {
      for (const [b2, d2] of neighborDistances) {
        if (b1 === b2) continue;
        if (d1.has(b2)) continue;

        let dist = manhattan([b1.x, b1.y, b1.z], [b2.x, b2.y, b2.z]);

        d1.set(b2, dist);
        d2.set(b1, dist);
      }
    }

    return neighborDistances;
  }

  reflect() {
    // console.log("turn");
    this.beacons.forEach((p) => p.reflect());
    this.scanners.forEach((p) => p.reflect());
  }

  roll() {
    // console.log("roll");
    this.beacons.forEach((p) => p.roll());
    this.scanners.forEach((p) => p.roll());
  }

  turn() {
    // console.log("turn");
    this.beacons.forEach((p) => p.turn());
    this.scanners.forEach((p) => p.turn());
  }

  turnReverse() {
    // console.log("turnReverse");
    this.beacons.forEach((p) => p.turnReverse());
    this.scanners.forEach((p) => p.turnReverse());
  }

  translate(translation) {
    this.beacons.forEach((p) => p.translate(translation));
    this.scanners.forEach((p) => p.translate(translation));
  }
}

const calculateTranslation = (from, to) => {
  return {
    x: to.x - from.x,
    y: to.y - from.y,
    z: to.z - from.z,
  };
};

const SIMILARITY_THREASHOLD = 12;

const isMatch = (d1, d2) => {
  const v1 = [...d1.values()];
  const v2 = [...d2.values()];

  let found = 0;
  for (const a of v1) {
    for (let i = 0; i < v2.length; i += 1) {
      let b = v2[i];
      if (a === b) {
        found += 1;
        v2.splice(i, 1);

        if (found === SIMILARITY_THREASHOLD - 1) {
          return true;
        }
      }
    }
  }

  return false;
};

const findMatchingPoints = (r1, r2) => {
  const rd1 = r1.getNeighborDistances();
  const rd2 = r2.getNeighborDistances();

  const p1 = [];
  const p2 = [];

  for (const [b1, d1] of rd1) {
    for (const [b2, d2] of rd2) {
      if (isMatch(d1, d2)) {
        p1.push(b1);
        p2.push(b2);

        break;
      }
    }
  }

  if (p1.length >= SIMILARITY_THREASHOLD) {
    return [p1, p2];
  }

  return null;
};

const baseOrigin = { x: 0, y: 0, z: 0 };

const defaultRotations = [
  "roll",
  "turn",
  "turn",
  "turn",
  "roll",
  "turnReverse",
  "turnReverse",
  "turnReverse",
  "roll",
  "turn",
  "turn",
  "turn",
  "roll",
  "turnReverse",
  "turnReverse",
  "turnReverse",
  "roll",
  "turn",
  "turn",
  "turn",
  "roll",
  "turnReverse",
  "turnReverse",
  "turnReverse",
];

const determineIfAligned = (p1, p2) => {
  // console.log("p1", p1.join("\n"));
  // console.log("p2", p2.join("\n"));
  let last = p1.length - 1;
  let middle = Math.floor(last / 2);

  return [0, middle, last].every((index) => {
    let a = p1[index];
    let b = p2[index];

    return a.x == b.x && a.y === b.y && a.z === b.z;
  });
};

const createRegions = (input) => {
  return input.map((detected, id) => {
    const region = new Region(id);

    region.addScanner(new Scanner(id));

    for (const [x, y, z] of detected) {
      region.addBeacon(new Beacon({ x, y, z }));
    }

    return region;
  });
};

const combineRegions = (regions) => {
  const [r1, ...unmerged] = regions;

  while (unmerged.length) {
    outer: for (let i = 0; i < unmerged.length; i += 1) {
      const r2 = unmerged[i];

      // if (r1 === r2) continue;
      // console.log(`Comparing region ${r1.id} and ${r2.id}`);

      const match = findMatchingPoints(r1, r2);
      if (!match) continue;

      const [p1, p2] = match;

      // const c1 = calculateCentroid(p1);
      // console.log(c1);
      const t1 = calculateTranslation(p1[0], baseOrigin);
      r1.translate(t1);

      // const c2 = calculateCentroid(p2);
      const t2 = calculateTranslation(p2[0], baseOrigin);
      r2.translate(t2);

      const rotations = [...defaultRotations];
      while (rotations.length) {
        const rotation = rotations.shift();
        // console.log(rotation);
        r2[rotation]();
        if (determineIfAligned(p1, p2)) {
          r1.addScanner(...r2.scanners);
          r1.addBeacon(...r2.beacons.filter((b) => !p2.includes(b)));
          unmerged.splice(i, 1);
          r1.translate({ x: t1.x * -1, y: t1.y * -1, z: t1.z * -1 });
          break outer;
        }
      }

      throw new Error("Never aligned!");
    }
  }

  return regions[0];
};

export const part1 = (input) => {
  const regions = createRegions(input);
  const finalRegion = combineRegions(regions);

  return finalRegion.beacons.length;
};

export const part2 = (input) => {
  const regions = createRegions(input);
  const finalRegion = combineRegions(regions);

  const pairs = getDistinctPairs(finalRegion.scanners);

  let max = 0;

  for (const pair of pairs) {
    let [a, b] = pair;
    let mag = manhattan([a.x, a.y, a.z], [b.x, b.y, b.z]);
    if (mag > max) max = mag;
  }

  return max;
};
