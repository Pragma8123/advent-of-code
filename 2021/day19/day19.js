// generated by prepare script
class Point {
  constructor({ x, y, z }) {
    this.x = x;
    this.y = y;
    this.z = z;
    // this.region = null;
  }

  toJSON() {
    const { x, y, z } = this;
    return { x, y, z };
  }

  toString() {
    const { x, y, z } = this;
    return `(${x}, ${y}, ${z})`;
  }

  translate({ x, y, z }) {
    this.x += x;
    this.y += y;
    this.z += z;
  }

  reflect() {
    let [x, y, z] = ["x", "y", "z"].map((a) =>
      a == "y" ? this[a] : this[a] * -1
    );
    Object.assign(this, { x, y, z });
  }

  roll() {
    let [x, y, z] = [this.x, this.z, -1 * this.y];
    Object.assign(this, { x, y, z });
  }

  turn() {
    let [x, y, z] = [this.y, -1 * this.x, this.z];
    Object.assign(this, { x, y, z });
  }

  turnReverse() {
    let [x, y, z] = [-1 * this.y, this.x, this.z];
    Object.assign(this, { x, y, z });
  }

  turnReverse() {
    let [x, y, z] = [-1 * this.y, this.x, this.z];
    Object.assign(this, { x, y, z });
  }
}
class Scanner extends Point {
  constructor(id) {
    super({ x: 0, y: 0, z: 0 });
    this.id = id;
  }
}

class Beacon extends Point {
  constructor(xyz) {
    super(xyz);
  }
}

class Region {
  constructor(id) {
    this.id = id;
    this.scanners = [];
    this.beacons = [];
  }

  addScanner(...scanners) {
    for (const scanner of scanners) {
      // scanner.region = this;
      this.scanners.push(scanner);
    }
  }

  addBeacon(...beacons) {
    for (const beacon of beacons) {
      const existing = this.beacons.find(
        (b) => b.x === beacon.x && b.y === beacon.y && b.z === beacon.z
      );

      if (existing) {
        console.log("discarding duplicate point");
        continue;
      }
      // beacon.region = this;
      this.beacons.push(beacon);
    }
  }

  getNeighborDistances() {
    const neighborDistances = new Map(this.beacons.map((b) => [b, new Map()]));

    for (const [b1, d1] of neighborDistances) {
      for (const [b2, d2] of neighborDistances) {
        if (b1 === b2) continue;
        if (d1.has(b2)) continue;

        let dist = Math.abs(b2.x - b1.x);
        dist += Math.abs(b2.y - b1.y);
        dist += Math.abs(b2.z - b1.z);

        d1.set(b2, dist);
        d2.set(b1, dist);
      }
    }

    return neighborDistances;
  }

  reflect() {
    // console.log("turn");
    this.beacons.forEach((p) => p.reflect());
    this.scanners.forEach((p) => p.reflect());
  }

  roll() {
    // console.log("roll");
    this.beacons.forEach((p) => p.roll());
    this.scanners.forEach((p) => p.roll());
  }

  turn() {
    // console.log("turn");
    this.beacons.forEach((p) => p.turn());
    this.scanners.forEach((p) => p.turn());
  }

  turnReverse() {
    // console.log("turnReverse");
    this.beacons.forEach((p) => p.turnReverse());
    this.scanners.forEach((p) => p.turnReverse());
  }

  translate(translation) {
    this.beacons.forEach((p) => p.translate(translation));
    this.scanners.forEach((p) => p.translate(translation));
  }
}

const calculateTranslation = (from, to) => {
  return {
    x: to.x - from.x,
    y: to.y - from.y,
    z: to.z - from.z,
  };
};

const calculateCentroid = (points) => {
  const len = points.length;

  let sX = 0;
  let sY = 0;
  let sZ = 0;

  for (const p of points) {
    sX += p.x;
    sY += p.y;
    sZ += p.z;
  }

  return {
    x: sX / len,
    y: sY / len,
    z: sZ / len,
  };
};

const SIMILARITY_THREASHOLD = 12;

const isMatch = (d1, d2) => {
  const v1 = [...d1.values()];
  const v2 = [...d2.values()];

  let found = 0;
  for (const a of v1) {
    for (let i = 0; i < v2.length; i += 1) {
      let b = v2[i];
      if (a === b) {
        found += 1;
        v2.splice(i, 1);

        if (found === SIMILARITY_THREASHOLD - 1) {
          return true;
        }
      }
    }
  }

  return false;
};

const findMatchingPoints = (r1, r2) => {
  const rd1 = r1.getNeighborDistances();
  const rd2 = r2.getNeighborDistances();

  const p1 = [];
  const p2 = [];

  for (const [b1, d1] of rd1) {
    for (const [b2, d2] of rd2) {
      if (isMatch(d1, d2)) {
        p1.push(b1);
        p2.push(b2);

        if (p1.length >= SIMILARITY_THREASHOLD) {
          return [p1, p2];
        } else {
          break;
        }
      }
    }
  }

  return null;
};

const baseOrigin = { x: 0, y: 0, z: 0 };

const defaultRotations = [
  "roll",
  "turn",
  "turn",
  "turn",
  "roll",
  "turnReverse",
  "turnReverse",
  "turnReverse",
  "roll",
  "turn",
  "turn",
  "turn",
  "roll",
  "turnReverse",
  "turnReverse",
  "turnReverse",
  "roll",
  "turn",
  "turn",
  "turn",
  "roll",
  "turnReverse",
  "turnReverse",
  "turnReverse",
];

const determineIfAligned = (p1, p2) => {
  // console.log("p1", p1.join("\n"));
  // console.log("p2", p2.join("\n"));
  let last = p1.length - 1;
  let middle = Math.floor(last / 2);

  return [0, middle, last].every((index) => {
    let a = p1[index];
    let b = p2[index];

    return a.x == b.x && a.y === b.y && a.z === b.z;
  });
};

const createRegions = (input) => {
  return input.map((detected, id) => {
    const region = new Region(id);

    region.addScanner(new Scanner(id));

    for (const [x, y, z] of detected) {
      region.addBeacon(new Beacon({ x, y, z }));
    }

    return region;
  });
};

const combineRegions = (regions) => {
  while (regions.length > 1) {
    for (const r1 of regions) {
      inner: for (let i = 0; i < regions.length; i += 1) {
        const r2 = regions[i];

        if (r1 === r2) continue;
        // console.log(`Comparing region ${r1.id} and ${r2.id}`);

        const match = findMatchingPoints(r1, r2);
        if (!match) continue;

        const [p1, p2] = match;

        const t1 = calculateTranslation(p1[0], baseOrigin);
        r1.translate(t1);

        const t2 = calculateTranslation(p2[0], baseOrigin);
        r2.translate(t2);

        const rotations = [...defaultRotations];
        while (rotations.length) {
          const rotation = rotations.shift();
          // console.log(rotation);
          r2[rotation]();
          if (determineIfAligned(p1, p2)) {
            r1.scanners.push(...r2.scanners);
            r1.beacons.push(...r2.beacons.filter((b) => !p2.includes(b)));
            regions.splice(i, 1);
            // r1.translate({ x: t1.x * -1, y: t1.y * -1, z: t1.z * -1 });
            continue inner;
          }
        }

        console.log(regions.length);

        throw new Error("never aligned");
      }
    }
  }

  return regions[0];
};

export const part1 = (input) => {
  const regions = createRegions(input);
  const finalRegion = combineRegions(regions);

  return finalRegion.beacons.length;
};

export const part2 = (input) => {
  const regions = createRegions(input);
  const finalRegion = combineRegions(regions);
  console.log(finalRegion);

  return false;
};
