// generated by prepare script
const DIRECTIONS_REGEX = /([xy])=(\d+)/gi;
const parseDirections = (directionsString) => {
  return [...directionsString.matchAll(DIRECTIONS_REGEX)].map(
    ([, axis, location]) => [axis, parseInt(location, 10)]
  );
};

const parseLocations = (locationString) => {
  return locationString.split(/\r?\n/).map((l) => l.split(",").map(Number));
};

const parseInput = (input) => {
  const [locationString, directionsString] = input;
  const locations = parseLocations(locationString);
  const directions = parseDirections(directionsString);

  return [locations, directions];
};

class GridPaper {
  data = {};

  constructor(dotLocations) {
    dotLocations.forEach(([x, y]) => {
      this.data[`${x},${y}`] = { x, y };
    });
  }

  fold = ([foldAxis, foldCoord]) => {
    const data = {};

    Object.values(this.data).forEach((pos) => {
      const posFoldAxisCoord = pos[foldAxis];

      if (posFoldAxisCoord < foldCoord) {
        data[`${pos.x},${pos.y}`] = pos;
        return;
      }

      const newPos = { ...pos };
      newPos[foldAxis] = foldCoord - (posFoldAxisCoord - foldCoord);

      const key = `${newPos.x},${newPos.y}`;
      if (!data[key]) data[key] = newPos;
    });

    this.data = data;
  };

  toString() {
    let maxX = 0;
    let maxY = 0;

    Object.values(this.data).forEach(({ x, y }) => {
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
    });

    return Array.from({ length: maxY + 1 }, (_v, y) => {
      return Array.from({ length: maxX + 1 }, (_v, x) => {
        return this.data[`${x},${y}`] ? "#" : " ";
      }).join(" ");
    }).join("\n");
  }
}

export const part1 = (input) => {
  const [locations, directions] = parseInput(input);
  const gridPaper = new GridPaper(locations);
  gridPaper.fold(directions[0]);

  return Object.values(gridPaper.data).length;
};

export const part2 = (input) => {
  const [locations, directions] = parseInput(input);
  const gridPaper = new GridPaper(locations);
  directions.forEach(gridPaper.fold);

  return String(gridPaper);
};
