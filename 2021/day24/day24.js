import _ from "lodash";

// generated by prepare script
const INITIAL_MEMORY = { w: 0, x: 0, y: 0, z: 0 };

class Engine {
  memory = { ...INITIAL_MEMORY };
  instructions = [];
  input = [];

  constructor(instructions) {
    this.instructions.push(...instructions);
  }

  addInput(...value) {
    this.input.push(...value);
  }

  clear() {
    this.memory = { ...INITIAL_MEMORY };
  }

  handleCalculation(op, a, b) {
    switch (op) {
      case "add": {
        return a + b;
      }

      case "mul": {
        return a * b;
      }

      case "div": {
        return Math.floor(a / b);
      }

      case "mod": {
        return a % b;
      }

      case "eql": {
        return Number(a === b);
      }
    }
  }

  run(...input) {
    this.addInput(...input);

    for (const inst of this.instructions) {
      let [op, a, b] = inst;

      if (op === "inp") {
        this.memory[a] = this.input.shift();
      } else {
        if (b !== undefined) b = this.memory[b] ?? Number(b);
        this.memory[a] = this.handleCalculation(op, this.memory[a], b);
      }
    }

    const finalMemory = { ...this.memory };
    this.clear();

    return finalMemory;
  }
}

const findZero = (engine, n) => {};

export const part1 = (instructions) => {
  const engine = new Engine(instructions);

  for (let x = 4; ; x = x - 1 || 9) {
    const input = Array.from({ length: 14 }, () => 9);
    input[0] = x;

    let inc = 1;

    for (let i = 1; i > 0; i += inc) {
      for (let n = input[i], minZ = Infinity; ; n = n - 1 || 9) {
        input[i] = n;
        const { z } = engine.run(...input);
        if (!z) return input;
        if (z === minZ) break;
        if (z < minZ) {
          minZ = z;
        }
      }
      if (i === 13) inc = -1;
      if (i === 1) inc = 1;
    }
  }
};

export const part2 = (input) => {
  return false;
};
