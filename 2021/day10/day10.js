// generated by prepare script

const types = {
  parens: { close: ")", open: "(", errorValue: 3, completeValue: 1 },
  squares: { close: "]", open: "[", errorValue: 57, completeValue: 2 },
  braces: { close: "}", open: "{", errorValue: 1197, completeValue: 3 },
  angles: { close: ">", open: "<", errorValue: 25137, completeValue: 4 },
};

const openMap = {
  "{": types.braces,
  "[": types.squares,
  "(": types.parens,
  "<": types.angles,
};

const closeMap = {
  "}": types.braces,
  "]": types.squares,
  ")": types.parens,
  ">": types.angles,
};

export const part1 = (arr) => {
  let t = 0;

  for (const line of arr) {
    let states = [];

    for (const c of line) {
      const opensGroup = openMap[c];
      if (opensGroup) {
        states.push(opensGroup);
      } else {
        const lastState = states.pop();
        const closeGroup = closeMap[c];
        if (closeGroup !== lastState) {
          t += closeGroup.errorValue;
          break;
        }
      }
    }
  }
  return t;
};

export const part2 = (input) => {
  const scores = [];

  for (const line of input) {
    let states = [];
    let valid = true;

    for (const c of line) {
      const opensGroup = openMap[c];
      if (opensGroup) {
        states.push(opensGroup);
      } else {
        const lastState = states.pop();
        const closeGroup = closeMap[c];
        if (closeGroup !== lastState) {
          valid = false;
          break;
        }
      }
    }

    if (!valid) continue;

    let score = 0;
    while (states.length) {
      let lastState = states.pop();
      score = score * 5 + lastState.completeValue;
    }
    scores.push(score);
  }

  return scores.sort((a, b) => b - a)[Math.ceil(scores.length / 2) - 1];
};
